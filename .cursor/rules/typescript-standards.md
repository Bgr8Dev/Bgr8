# TypeScript Coding Standards

## Component Structure

### Functional Components
- Use functional components with TypeScript
- Define proper interfaces for props
- Use React hooks appropriately
- Follow the existing naming conventions (PascalCase for components)

### Component Patterns
- Use proper TypeScript interfaces for all props
- Implement proper state management with hooks
- Use TypeScript generics when appropriate
- Follow the existing component structure patterns

## TypeScript Best Practices

### Type Definitions
- Define interfaces for all data structures
- Use proper typing for React props and state
- Avoid `any` type - use specific types or `unknown`
- Use union types and type guards appropriately
- Define return types for functions when not obvious

### Type Safety
- Use strict TypeScript configuration
- Implement proper error handling with typed errors
- Use type assertions sparingly and safely
- Leverage TypeScript's type inference when appropriate

### Interface Design
- Create interfaces for component props
- Use generic types for reusable components
- Define proper types for API responses
- Use branded types for domain-specific values

## Code Organization

### File Structure
- One component per file for complex components
- Group related types in separate files
- Use barrel exports for clean imports
- Follow the existing file naming conventions

### Function Definitions
- Use arrow functions for component definitions
- Define proper parameter and return types
- Use function overloads when appropriate
- Implement proper error handling

## React-Specific TypeScript

### Hooks Usage
- Type custom hooks properly
- Use proper typing for useState and useEffect
- Implement proper dependency arrays
- Use useCallback and useMemo with proper types

### Event Handling
- Type event handlers properly
- Use React's built-in event types
- Implement proper form handling with types
- Use proper ref typing

## Error Handling

### Type-Safe Error Handling
- Define custom error types
- Use proper error boundaries with TypeScript
- Implement type-safe error recovery
- Use discriminated unions for error states

### Validation
- Use TypeScript for runtime validation
- Implement proper input validation types
- Use type guards for runtime checks
- Leverage TypeScript for compile-time validation

## Performance Considerations

### Type Optimization
- Use const assertions where appropriate
- Implement proper memoization with types
- Use TypeScript's strict mode features
- Optimize type checking performance

### Code Splitting
- Use proper typing for lazy-loaded components
- Implement type-safe dynamic imports
- Use proper typing for code-split routes
- Handle loading states with proper types

## Forbidden TypeScript Practices

- DO NOT use `any` type without justification
- DO NOT bypass TypeScript's type checking
- DO NOT create components without proper TypeScript types
- DO NOT ignore TypeScript errors or warnings
- DO NOT use type assertions without proper validation
