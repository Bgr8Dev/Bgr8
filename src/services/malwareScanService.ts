/**
 * Malware Scanning Service
 * 
 * Provides malware detection capabilities for file uploads using:
 * - VirusTotal API (file hash lookup and file scanning)
 * - Future: ClamAV integration support
 * 
 * This service helps protect the application from malicious file uploads.
 */

import { FILE_UPLOAD } from '../config/security';

export interface ScanResult {
  isSafe: boolean;
  isMalicious: boolean;
  scanDate: Date;
  vendor?: string;
  details?: string;
  error?: string;
}

export interface MalwareScanOptions {
  enableScanning?: boolean;
  useHashOnly?: boolean; // Use hash lookup instead of file upload (faster, but requires file to be known)
  timeout?: number;
}

class MalwareScanService {
  private apiKey: string | null = null;
  private enabled: boolean = false;
  private readonly virusTotalHashApi = 'https://www.virustotal.com/vtapi/v2/file/report';
  private readonly virusTotalScanApi = 'https://www.virustotal.com/vtapi/v2/file/scan';
  private readonly defaultTimeout = 30000; // 30 seconds

  /**
   * Initialize the malware scanning service
   */
  initialize(): void {
    // Get API key from environment variables
    const apiKey = import.meta.env.VITE_VIRUSTOTAL_API_KEY;
    
    if (apiKey && apiKey !== 'your_virustotal_api_key_here') {
      this.apiKey = apiKey;
      this.enabled = true;
    } else {
      console.warn('[MalwareScan] VirusTotal API key not configured. Malware scanning is disabled.');
      this.enabled = false;
    }
  }

  /**
   * Check if malware scanning is enabled and configured
   */
  isEnabled(): boolean {
    return this.enabled && this.apiKey !== null;
  }

  /**
   * Calculate SHA256 hash of a file
   */
  private async calculateFileHash(file: File): Promise<string> {
    const buffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
  }

  /**
   * Check file hash against VirusTotal database
   * This is faster and doesn't require uploading the file
   */
  private async scanFileHash(fileHash: string): Promise<ScanResult> {
    if (!this.apiKey) {
      return {
        isSafe: true, // Fail open if not configured
        isMalicious: false,
        scanDate: new Date(),
        error: 'VirusTotal API key not configured'
      };
    }

    try {
      const params = new URLSearchParams({
        apikey: this.apiKey,
        resource: fileHash
      });

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.defaultTimeout);

      const response = await fetch(`${this.virusTotalHashApi}?${params}`, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          'Accept': 'application/json'
        }
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        if (response.status === 204) {
          // Rate limit exceeded
          console.warn('[MalwareScan] VirusTotal rate limit exceeded');
          return {
            isSafe: true, // Fail open on rate limit
            isMalicious: false,
            scanDate: new Date(),
            error: 'Rate limit exceeded'
          };
        }
        throw new Error(`VirusTotal API error: ${response.status}`);
      }

      const data = await response.json();

      // Response code meanings:
      // 0: Not found in database
      // 1: Found, scan results available
      // -2: Still queued for scanning
      if (data.response_code === 0) {
        // File not in database - could be safe or unknown
        // For security, we might want to block unknown files in production
        return {
          isSafe: true, // Fail open for unknown files
          isMalicious: false,
          scanDate: new Date(),
          details: 'File not found in VirusTotal database',
          vendor: 'VirusTotal'
        };
      } else if (data.response_code === -2) {
        // Still queued - treat as safe for now
        return {
          isSafe: true,
          isMalicious: false,
          scanDate: new Date(),
          details: 'File scan in progress',
          vendor: 'VirusTotal'
        };
      } else if (data.response_code === 1) {
        // Scan results available
        const positives = data.positives || 0;
        const total = data.total || 0;
        const isMalicious = positives > 0;

        return {
          isSafe: !isMalicious,
          isMalicious: isMalicious,
          scanDate: new Date(),
          details: isMalicious 
            ? `Detected by ${positives}/${total} security vendors` 
            : `Scanned and clean (0/${total} detections)`,
          vendor: 'VirusTotal'
        };
      }

      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        error: 'Unknown response code'
      };

    } catch (error) {
      console.error('[MalwareScan] Hash scan error:', error);
      
      // Fail open on error (don't block uploads if scan fails)
      // In production, you might want to fail closed for certain error types
      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Upload file to VirusTotal for scanning
   * Note: This uploads the file to VirusTotal, not to your storage
   */
  private async uploadFileForScanning(file: File): Promise<ScanResult> {
    if (!this.apiKey) {
      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        error: 'VirusTotal API key not configured'
      };
    }

    try {
      const formData = new FormData();
      formData.append('apikey', this.apiKey);
      formData.append('file', file);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.defaultTimeout);

      const response = await fetch(this.virusTotalScanApi, {
        method: 'POST',
        body: formData,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        if (response.status === 204) {
          console.warn('[MalwareScan] VirusTotal rate limit exceeded');
          return {
            isSafe: true,
            isMalicious: false,
            scanDate: new Date(),
            error: 'Rate limit exceeded'
          };
        }
        throw new Error(`VirusTotal API error: ${response.status}`);
      }

      const data = await response.json();

      if (data.response_code === 1) {
        // File uploaded, get scan ID
        // Note: This returns immediately, actual scan happens asynchronously
        // You would need to poll the scan_id later, but for immediate scanning
        // we use hash lookup instead
        return {
          isSafe: true,
          isMalicious: false,
          scanDate: new Date(),
          details: 'File uploaded for scanning (scan in progress)',
          vendor: 'VirusTotal'
        };
      }

      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        error: 'Upload failed'
      };

    } catch (error) {
      console.error('[MalwareScan] File upload scan error:', error);
      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Scan a file for malware
   * 
   * @param file - The file to scan
   * @param options - Scanning options
   * @returns Promise resolving to scan result
   */
  async scanFile(file: File, options: MalwareScanOptions = {}): Promise<ScanResult> {
    const { enableScanning = true, useHashOnly = true, timeout = this.defaultTimeout } = options;

    // If scanning is disabled, return safe result
    if (!enableScanning || !this.isEnabled()) {
      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        details: 'Scanning disabled'
      };
    }

    // Check file size limit (VirusTotal has limits)
    const maxScanSize = 32 * 1024 * 1024; // 32MB VirusTotal limit
    if (file.size > maxScanSize) {
      console.warn(`[MalwareScan] File ${file.name} exceeds VirusTotal size limit (32MB)`);
      return {
        isSafe: true, // Fail open for oversized files
        isMalicious: false,
        scanDate: new Date(),
        error: 'File too large for scanning'
      };
    }

    try {
      if (useHashOnly) {
        // Calculate hash and check against VirusTotal database
        const fileHash = await this.calculateFileHash(file);
        return await this.scanFileHash(fileHash);
      } else {
        // Upload file to VirusTotal for scanning
        // Note: This is slower and uses more API quota
        return await this.uploadFileForScanning(file);
      }
    } catch (error) {
      console.error('[MalwareScan] Scan error:', error);
      return {
        isSafe: true,
        isMalicious: false,
        scanDate: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Scan multiple files for malware
   * 
   * @param files - Array of files to scan
   * @param options - Scanning options
   * @returns Promise resolving to array of scan results
   */
  async scanFiles(files: File[], options: MalwareScanOptions = {}): Promise<ScanResult[]> {
    const scanPromises = files.map(file => this.scanFile(file, options));
    return Promise.all(scanPromises);
  }

  /**
   * Validate scan results and throw if malicious files found
   * 
   * @param results - Array of scan results
   * @param fileNames - Array of file names (for error messages)
   * @throws Error if any malicious files are detected
   */
  validateScanResults(results: ScanResult[], fileNames: string[]): void {
    const maliciousFiles: string[] = [];

    results.forEach((result, index) => {
      if (result.isMalicious) {
        maliciousFiles.push(fileNames[index] || `File ${index + 1}`);
      }
    });

    if (maliciousFiles.length > 0) {
      throw new Error(
        `Malware detected in the following files: ${maliciousFiles.join(', ')}. ` +
        'These files have been blocked for security reasons.'
      );
    }
  }
}

// Export singleton instance
export const malwareScanService = new MalwareScanService();

// Initialize on import
malwareScanService.initialize();
